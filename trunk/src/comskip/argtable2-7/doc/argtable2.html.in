<!-- Creator     : groff version 1.18.1 -->
<!-- CreationDate: Fri Dec 23 00:39:57 2005 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>ARGTABLE2</title>
</head>
<body>

<h1 align=center>ARGTABLE2</h1>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#FUNCTION REFERENCE">FUNCTION REFERENCE</a><br>
<a href="#LITERAL OPTIONS (struct arg_lit)">LITERAL OPTIONS (struct arg_lit)</a><br>
<a href="#INTEGER OPTIONS (struct arg_int)">INTEGER OPTIONS (struct arg_int)</a><br>
<a href="#DOUBLE OPTIONS (struct arg_dbl)">DOUBLE OPTIONS (struct arg_dbl)</a><br>
<a href="#STRING OPTIONS (struct arg_str)">STRING OPTIONS (struct arg_str)</a><br>
<a href="#REGULAR EXPRESSION OPTIONS (struct arg_rex)">REGULAR EXPRESSION OPTIONS (struct arg_rex)</a><br>
<a href="#FILENAME OPTIONS (struct arg_file)">FILENAME OPTIONS (struct arg_file)</a><br>
<a href="#DATE/TIME OPTIONS (struct arg_date)">DATE/TIME OPTIONS (struct arg_date)</a><br>
<a href="#REMARK OPTIONS (struct arg_rem)">REMARK OPTIONS (struct arg_rem)</a><br>
<a href="#END-OF-TABLE OPTIONS (struct arg_end)">END-OF-TABLE OPTIONS (struct arg_end)</a><br>
<a href="#FILES">FILES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>
<a name="NAME"></a>
<h2>NAME</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>argtable2 &minus; an ANSI C library for parsing GNU style
command line options</p>
</td>
</table>
<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>#include &lt;argtable2.h&gt;

struct <b>arg_lit
</b>struct <b>arg_int
</b>struct <b>arg_dbl
</b>struct <b>arg_str
</b>struct <b>arg_rex
</b>struct <b>arg_file
</b>struct <b>arg_date
</b>struct <b>arg_rem
</b>struct <b>arg_end

</b>struct <b>arg_xxx</b>* <b>arg_xxx0</b>(...)
struct <b>arg_xxx</b>* <b>arg_xxx1</b>(...)
struct <b>arg_xxx</b>* <b>arg_xxxn</b>(...)

int <b>arg_nullcheck</b>(void **argtable)
int <b>arg_parse</b>(int argc, char **argv, void **argtable)
void <b>arg_print_option</b>(FILE *fp, const char *shortopts, const char *longopts,
        const char *datatype, const char *suffix)
void <b>arg_print_syntax</b>(FILE *fp, void **argtable, const char *suffix)
void <b>arg_print_syntaxv</b>(FILE *fp, void **argtable, const char *suffix)
void <b>arg_print_glossary</b>(FILE *fp, void **argtable, const char *format)
void <b>arg_print_glossary_gnu</b>(FILE *fp, void **argtable)
void <b>arg_print_errors</b>(FILE *fp, struct arg_end *end, const char *progname)
void <b>arg_freetable</b>(void **argtable, size_t n)

</pre>
</td>
</table>
<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Argtable is an ANSI C library for parsing GNU style
command line arguments with a minimum of fuss. It enables
the programmer to define their program&rsquo;s argument
syntax directly in the source code as an array of structs.
The command line is then parsed according to that
specification and the resulting values stored directly into
user-defined program variables where they are accessible to
the main program.</p>
<!-- INDENTATION -->
<p>This man page is only for reference. Introductory and
advanced texts on argtable should be available on this
system in pdf, html, and postscript from under
<b>@prefix@/share/doc/argtable2/</b> along with example
source code. Alternatively refer to the argtable homepage at
http://argtable.sourceforge.net.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructing an arg_xxx data structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Each <b>arg_xxx</b> struct has it own unique set of
constructor functions and while these may differ slightly
between <b>arg_xxx</b> structs, they are generally of the
form:</p>
<!-- INDENTATION -->
<p>struct <b>arg_xxx* arg_xxx0</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
<!-- INDENTATION -->
<p>struct <b>arg_xxx* arg_xxx1</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
<!-- INDENTATION -->
<p>struct <b>arg_xxx* arg_xxxn</b> (const char *shortopts,
const char *longopts, const char *datatype, int mincount,
int maxcount, const char *glossary)</p>
<!-- INDENTATION -->
<p>The <b>arg_xxx0()</b> and <b>arg_xxx1()</b> forms are
merely abbreviated forms of <b>arg_xxxn()</b> and are
provided as a convenience for the most common arrangements
of command line options; namely those that have zero-or-one
occurrences (mincount=0,maxcount=1) and those that have one
exactly one occurrence (mincount=1,maxcount=1)
respectively.</p>
<!-- INDENTATION -->
<p>The <i>const char* shortopts</i> parameter defines the
option&rsquo;s short form tag (eg: -x, -k3,
-D&quot;macro&quot;). It can be left as NULL if a short
option is not required, otherwise use it to specify the
desired short option character in the string (without the
leading &quot;-&quot; and without any whitespace). For
example, the short option -v is defined simply as
&quot;v&quot;. In fact, a command line option may have
multiple alternate short form tags defined for it by
concatenating the desired characters into the shortopts
string. For instance &quot;abc&quot; defines an option which
will accept any of the three equivalent short forms -a, -b,
-c interchangeably.</p>
<!-- INDENTATION -->
<p>The <i>const char* longopts</i> parameter is similar to
<i>shortopts</i>, except it defines the option&rsquo;s long
form tags (eg: --help, --depth=3, --name=myfile.txt). It too
can be left as NULL if not required, and it too can have
multiple equivalent tags defined but these must be separated
by commas. For example, if we wish to define two equivalent
long options --quiet and --silent then we would give
longopts as &quot;quiet,silent&quot;. Remember not to
include any whitespace.</p>
<!-- INDENTATION -->
<p>If both <i>shortopts</i> and <i>longopts</i> are given as
NULL then the resulting option is an untagged argument.</p>
<!-- INDENTATION -->
<p>The <i>const char* datatype</i> parameter is a
descriptive string you can use to customize the appearance
of the argument data type in error messages and so forth. It
does not affect the actual data type definition as that is a
fixed property of the <b>arg_xxx</b> struct. So for example,
defining a <i>datatype</i> of &quot;&lt;bar&gt;&quot; will
result in the option being display something like &quot;-x
&lt;bar&gt;&quot; or &quot;--foo=&lt;bar&gt;&quot; depending
upon your option tags. If given as NULL, the <i>datatype</i>
string will revert to the default value for the particular
<b>arg_xxx</b> struct. You can effectively disable the
default by specifying <i>datatype</i> as an empty
string.</p>
<!-- INDENTATION -->
<p>The <i>int mincount</i> parameter specifies the minimum
number of occurrences that the option must appear on the
command line. If the option does not appear at least that
many times then the parser reports it as a syntax error. The
<i>mincount</i> defaults to 0 for the <b>arg_xxx0()</b>
functions and 1 for <b>arg_xxx1()</b> functions.</p>
<!-- INDENTATION -->
<p>The <i>int maxcount</i> parameter specifies the maximum
number of occurrences that the option may appear on the
command line. Any occurrences beyond the maximum are
discarded by the parser reported as syntax errors. The
<i>maxcount</i> defaults to 1 for both the <b>arg_xxx0()</b>
and <b>arg_xxx1()</b> functions.</p>
<!-- INDENTATION -->
<p>The <i>const char* glossary</i> parameter is another
descriptive string but this one appears in the glossary
table summarizing the program&rsquo;s command line options.
The glossary table is generated automatically by the
<b>arg_print_glossary</b> function (see later). For example,
a glossary string of &quot;the foobar factor&quot; would
appear in the glossary table along side the option something
like:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><tt>--foo=&lt;bar&gt; the foobar factor</tt></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Specifying a NULL glossary string causes that option to
be omitted from the glossary table.</p>
<!-- INDENTATION -->
<p>See below for the exact definitions of the individual
<b>arg_xxx</b> structs and their constructor functions.</p>
</td>
</table>
<a name="FUNCTION REFERENCE"></a>
<h2>FUNCTION REFERENCE</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>int arg_nullcheck (void **argtable)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Returns non-zero if the <i>argtable[]</i> array contains
any NULL entries up until the terminating <b>arg_end*</b>
entry. Returns zero otherwise.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>int arg_parse (int argc, char **argv, void
**argtable)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Parse the command line arguments in <i>argv[]</i> using
the command line syntax specified in <i>argtable[]</i>,
returning the number of errors encountered. Error details
are recorded in the argument table&rsquo;s <b>arg_end</b>
structure from where they can be displayed later with the
<b>arg_print_errors</b> function. Upon a successful parse,
the <b>arg_xxx</b> structures referenced in
<i>argtable[]</i> will contain the argument values extracted
from the command line.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_option (FILE *fp, const char
*shortopts, const char *longopts, const char *datatype,
const char *suffix)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This function prints an option&rsquo;s syntax, as in
<b>-K|--scalar=&lt;int&gt;</b>, where the short options,
long options, and datatype are all given as parameters of
this function. It is primarily used within the
<b>arg_xxx</b> structures&rsquo; <i>errorfn</i> functions as
a way of displaying an option&rsquo;s syntax inside of error
messages. However, it can also be used in user code if
desired. The <i>suffix</i> string is provided as a
convenience for appending newlines and so forth to the end
of the display and can be given as NULL if not required.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_syntax (FILE *fp, void **argtable,
const char *suffix)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Prints the GNU style command line syntax for the given
argument table, as in: [-abcv] [--scalar=&lt;n&gt;] [-o
myfile] &lt;file&gt; [&lt;file&gt;]<br>
The <i>suffix</i> string is provided as a convenience for
appending newlines and so forth to the end of the display
and can be given as NULL if not required.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_syntaxv (FILE *fp, void **argtable,
const char *suffix)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Prints the verbose form of the command line syntax for
the given argument table, as in: [-a] [-b] [-c]
[--scalar=&lt;n&gt;] [-o myfile] [-v|--verbose] &lt;file&gt;
[&lt;file&gt;]<br>
The <i>suffix</i> string is provided as a convenience for
appending newlines and so forth to the end of the display
and can be given as NULL if not required.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_glossary (FILE *fp, void **argtable,
const char *format)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Prints a glossary table describing each option in the
given argument table. The <i>format</i> string is passed to
printf to control the formatting of each entry in the the
glossary. It must have exactly two &quot;%s&quot; format
parameters as in &quot;%-25s %s\n&quot;, the first is for
the option&rsquo;s syntax and the second for its glossary
string. If an option&rsquo;s glossary string is NULL then
that option in omitted from the glossary display.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_glossary_gnu (FILE *fp, void
**argtable)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>An alternate form of <b>arg_print_glossary()</b> that
prints the glossary using strict GNU formatting conventions
wherein long options are vertically aligned in a second
column, and lines are wrapped at 80 characters.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_print_errors (FILE *fp, struct arg_end *end,
const char *progname)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Prints the details of all errors stored in the <i>end</i>
data structure. The <i>progname</i> string is prepended to
each error message.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>void arg_freetable (void ** argtable, size_t
n)</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Deallocates the memory used by each <b>arg_xxx</b> struct
referenced by <i>argtable[]</i>. It does this by calling
<b>free</b> for each of the <i>n</i> pointers in the
argtable array and then nulling them for safety.</p>
</td>
</table>
<a name="LITERAL OPTIONS (struct arg_lit)"></a>
<h2>LITERAL OPTIONS (struct arg_lit)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Command line examples</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>-x, -y, -z, --help, --verbose</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_lit
</b>   {
   struct <b>arg_hdr</b> hdr;
   int count;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Functions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_lit* arg_lit0</b> (const char *shortopts,
const char *longopts, const char *glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_lit* arg_lit1</b> (const char *shortopts,
const char *longopts, const char *glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_lit* arg_litn</b> (const char *shortopts,
const char *longopts, int mincount, int maxcount, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Literal options take no argument values so all that is to
be seen in the <b>arg_lit</b> struct is the <i>count</i> of
the number of times the option was present on the command
line. Upon a successful parse, <i>count</i> is guaranteed to
be within the <i>mincount</i> and <i>maxcount</i> limits set
for the option at construction.</p>
</td>
</table>
<a name="INTEGER OPTIONS (struct arg_int)"></a>
<h2>INTEGER OPTIONS (struct arg_int)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Command line examples</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>-x2, -y 7, -z-3, --size=734, --count 124</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_int
</b>   {
   struct <b>arg_hdr</b> hdr;
   int count;
   int *ival;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Functions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_int* arg_int0</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_int* arg_int1</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_int* arg_intn</b> (const char *shortopts,
const char *longopts, const char *datatype, int mincount,
int maxcount, const char *glossary</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The <b>arg_int</b> struct contains the <i>count</i> of
the number of times the option was present on the command
line and a pointer (<i>ival</i>) to an array containing the
integer values given with those particular options. The
array is fixed at construction time to hold <i>maxcount</i>
integers at most.</p>
<!-- INDENTATION -->
<p>Upon a successful parse, <i>count</i> is guaranteed to be
within the <i>mincount</i> and <i>maxcount</i> limits set
for the option at construction with the appropriate values
store in the <i>ival</i> array. The parser will not accept
any values beyond that limit.</p>
<!-- INDENTATION -->
<p>It is quite acceptable to set default values in the
<i>ival</i> array prior to calling arg_parse if desired as
the parser does alter <i>ival</i> entries for which no
command line argument is received.</p>
</td>
</table>
<a name="DOUBLE OPTIONS (struct arg_dbl)"></a>
<h2>DOUBLE OPTIONS (struct arg_dbl)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Command line examples</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>-x2.234, -y 7e-03, -z-3.3E+6, --pi=3.1415, --tolerance
1.0E-6</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_dbl
</b>   {
   struct <b>arg_hdr</b> hdr;
   int count;
   double *dval;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Functions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_dbl* arg_dbl0</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_dbl* arg_dbl1</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_dbl* arg_dbln</b> (const char *shortopts,
const char *longopts, const char *datatype, int mincount,
int maxcount, const char *glossary</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Like <b>arg_int</b> but the arguments values are stored
as doubles in <i>dval</i>.</p>
</td>
</table>
<a name="STRING OPTIONS (struct arg_str)"></a>
<h2>STRING OPTIONS (struct arg_str)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Command line examples</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>-Dmacro, -t mytitle, -m &quot;my message string&quot;,
--title=&quot;hello world&quot;</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_str
</b>   {
   struct <b>arg_hdr</b> hdr;
   int count;
   const char **sval;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Functions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_str* arg_str0</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_str* arg_str1</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_str* arg_strn</b> (const char *shortopts,
const char *longopts, const char *datatype, int mincount,
int maxcount, const char *glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The <b>arg_str</b> struct contains the <i>count</i> of
the number of times the option was present on the command
line and a pointer (<i>sval</i>) to an array containing
pointers to the parsed string values. The array is fixed at
construction time to hold <i>maxcount</i> string pointers at
most. These pointers in this array reference the actual
command line string buffers stored in argv[], so the string
contents should not be should not be altered. Although it is
quite acceptable to set default string pointers in the
<i>sval</i> array prior to calling arg_parse as the parser
does alter them if no matching command line argument is
received.</p>
</td>
</table>
<a name="REGULAR EXPRESSION OPTIONS (struct arg_rex)"></a>
<h2>REGULAR EXPRESSION OPTIONS (struct arg_rex)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Command line examples</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>&quot;hello world&quot;, -t mytitle, -m &quot;my message
string&quot;, --title=&quot;hello world&quot;</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_rex
</b>   {
   struct <b>arg_hdr</b> hdr;
   int count;
   const char **sval;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Functions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_rex* arg_rex0</b> (const char *shortopts,
const char *longopts, const char *pattern, const char
*datatype, int flags, const char *glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_rex* arg_rex1</b> (const char *shortopts,
const char *longopts, const char *pattern, const char
*datatype, int flags, const char *glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_rex* arg_rexn</b> (const char *shortopts,
const char *longopts, const char *pattern, const char
*datatype, int mincount, int maxcount, int flags, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Like <b>arg_str</b> but but the string argument values
are only accepted if they match a predefined regular
expression. The regular expression is defined by the
<i>pattern</i> parameter passed to the <i>arg_rex</i>
constructor. The regular expression parsing is done using
regex, and its behaviour can be controlled via standard
regex bit flags which are passed to argtable via the
<i>flags</i> parameter in the <i>arg_rex</i> conbstructors.
However the only two regex flags that are relevant to
argtable are REG_EXTENDED (use extended regular expressions
rather than basic ones) and REG_ICASE (ignore case). These
may be logically ORed if desired. This argument type is
useful for matching command line keywords, particularly if
case insensitive strings or pattern matching is required.
See <b>regex(3)</b> for more details of regular expression
matching.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Restrictions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Argtable does not support <b>arg_date</b> functionality
under Microsoft Windows platforms as the Microsoft compilers
do include the necessary <b>regex</b> support as
standard.</p>
</td>
</table>
<a name="FILENAME OPTIONS (struct arg_file)"></a>
<h2>FILENAME OPTIONS (struct arg_file)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Command line xamples</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>-o myfile, -Ihome/foo/bar, --input=~/doc/letter.txt,
--name a.out</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_file
</b>   {
   struct <b>arg_hdr</b> hdr;
   int count;
   const char **filename;
   const char **basename;
   const char **extension;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Functions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_file* arg_file0</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_file* arg_file1</b> (const char *shortopts,
const char *longopts, const char *datatype, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_file* arg_filen</b> (const char *shortopts,
const char *longopts, const char *datatype, int mincount,
int maxcount, const char *glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Like <b>arg_str</b> but the argument strings are presumed
to have filename qualities so some additional pasring is
done to separate out the filename&rsquo;s basename and
extension (if they exist). The three arrays filename[],
basename[], extension[] each store up to maxcount entries,
and the i&rsquo;th entry of each of these arrays refer to
different components of the same string buffer.</p>
<!-- INDENTATION -->
<p>For instance, <b>-o /home/heitmann/mydir/foo.txt</b>
would be parsed as:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%"></td>
<td width="83%">
<pre>filename[i]  = &quot;/home/heitmann/mydir/foo.txt&quot;
basename[i]  =                      &quot;foo.txt&quot;
extension[i] =                          &quot;txt&quot;
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>If the filename has no leading path then the basename is
the same as the filename, and if no extension could be
identified then it is given as NULL. Note that filename
extensions are defined as all text following the last
&quot;.&quot; in the filename. Thus <b>-o foo</b> would be
parsed as:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%"></td>
<td width="83%">
<pre>filename[i]  = &quot;foo&quot;
basename[i]  = &quot;foo&quot;
extension[i] = NULL
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>As with arg_str, the string pointers in
<i>filename[]</i>, <i>basename[]</i>, and <i>extension[]</i>
actually refer to the original <i>argv[]</i> command line
string buffers so you should not attempt to alter them.</p>
<!-- INDENTATION -->
<p>Note also that the parser only ever treats the filenames
as strings and never attempts to open them as files or
perform any directory lookups on them.</p>
</td>
</table>
<a name="DATE/TIME OPTIONS (struct arg_date)"></a>
<h2>DATE/TIME OPTIONS (struct arg_date)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Command line examples</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>12/31/04, -d 1982-11-28, --time 23:59</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_date
</b>   {
   struct <b>arg_hdr</b> hdr;
   const char *format;
   int count;
   struct tm *tmval;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Functions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_date* arg_date0</b> (const char *shortopts,
const char *longopts, const char *format, const char
*datatype, const char *glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_date* arg_date1</b> (const char *shortopts,
const char *longopts, const char *format, const char
*datatype, const char *glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_date* arg_daten</b> (const char *shortopts,
const char *longopts, const char *format, const char
*datatype, int mincount, int maxcount, const char
*glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Accepts a timestamp string from the command line and
converts it to <i>struct tm</i> format using the system
<b>strptime</b> function. The time format is defined by the
<i>format</i> string passed to the <i>arg_date</i>
constructor, and is passed directly to <b>strptime</b>. See
<b>strptime(3)</b> for more details on the format
string.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Restrictions</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Argtable does not support <b>arg_date</b> functionality
under Microsoft Windows as the Microsoft compilers do
include the necessary <b>strptime</b> support as
standard.</p>
</td>
</table>
<a name="REMARK OPTIONS (struct arg_rem)"></a>
<h2>REMARK OPTIONS (struct arg_rem)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_rem
</b>   {
   struct <b>arg_hdr</b> hdr;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Function</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_rem* arg_rem</b> (const char* datatype,
const char* glossary)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The <b>arg_rem</b> struct is a dummy struct in the sense
it does not represent a command line option to be parsed.
Instead it provides a means to include additional
<i>datatype</i> and <i>glossary</i> strings in the output of
the <b>arg_print_syntax</b>, <b>arg_print_syntaxv</b>, and
<b>arg_print_glossary functions</b>. As such, <b>arg_rem</b>
structs may be used in the argument table to insert
additional lines of text into the glossary descriptions or
to insert additional text fields into the syntax
description. It has no data members apart from the mandatory
<i>arg_hdr</i> struct.</p>
</td>
</table>
<a name="END-OF-TABLE OPTIONS (struct arg_end)"></a>
<h2>END-OF-TABLE OPTIONS (struct arg_end)</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Data Structure</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre>struct <b>arg_end
</b>   {
   struct <b>arg_hdr</b> hdr;
   int count;
   int *error;
   void **parent;
   const char **argval;
   };
</pre>
</td>
</table>
<!-- INDENTATION -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Constructor Function</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>struct <b>arg_end* arg_end</b> (int maxerrors)</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%"></td>
<td width="95%">
<p><b>Description</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The arg_end struct is primarily used to mark the end of
an argument table and doesn&rsquo;t represent any command
line option. Every argument table must have an
<b>arg_end</b> structure as its last entry.</p>
<!-- INDENTATION -->
<p>Apart from terminating the argument table, the
<b>arg_end</b> structure also stores the error codes
generated by the <b>arg_parse</b> function as it attempts to
parse the command line with the given argument table. The
<i>maxerrors</i> parameter passed to the <b>arg_end</b>
constructor specifies the maximum number of errors that the
structure can store. Any further errors are discarded and
replaced with the single error code ARG_ELIMIT which is
later reported to the user by the message &quot;too many
errors&quot;. A <i>maxerrors</i> limit of 20 is quite
reasonable.</p>
<!-- INDENTATION -->
<p>The <b>arg_print_errors</b> function will print the
errors stored in the <b>arg_end</b> struct in the same order
as they occurred, so there is no need to understand the
internals of the <b>arg_end</b> struct.</p>
<!-- INDENTATION -->
<p>For those that are curious, the three arrays
<i>error[]</i>, <i>parent[]</i>, and <i>argval[]</i> are
each allocated <i>maxerrors</i> entries at construction. As
usual, the <i>count</i> variable gives the number of entries
actually stored in these arrays. The same value applies to
all three arrays as the i&rsquo;th entry of each all refer
to different aspects of the same error condition.</p>
<!-- INDENTATION -->
<p>The <i>error[i]</i> entry holds the error code returned
by the <i>hdr.scanfn</i> function of the particular
<b>arg_xxx</b> that is reporting the error. The meaning if
the code is usually known only to the issuing <b>arg_xxx</b>
struct. The predefined error codes that <b>arg_end</b>
handles from the parser itself are the exceptions.</p>
<!-- INDENTATION -->
<p>The <i>parent[i]</i> entry points to the parent
<b>arg_xxx</b> structure that reported the error. That same
<b>arg_xxx</b> structure is also responsible for displaying
a pertinent error message when called on to do so by the
<b>arg_print_errors</b> function. It calls the
<i>hdr.errorfn</i> function of each parent <b>arg_xxx</b>
struct listed in the <b>arg_end</b> structure.</p>
<!-- INDENTATION -->
<p>Lastly, the <i>argval[i]</i> entry points to the command
line argument at which the error occurred, although this may
be NULL when there is no relevant command line value. For
instance, if an error reports a missing option then there
will be no matching command line argument value.</p>
</td>
</table>
<a name="FILES"></a>
<h2>FILES</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>@prefix@/include/argtable2.h<br>
@prefix@/lib/libargtable2.a<br>
@prefix@/lib/libargtable2.so<br>
@prefix@/man3/argtable2.3<br>
@prefix@/share/doc/argtable2/<br>
@prefix@/share/doc/argtable2/example/</p>
</td>
</table>
<a name="AUTHOR"></a>
<h2>AUTHOR</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Stewart Heitmann
&lt;sheitmann@users.sourceforge.net&gt;</p>
</td>
</table>
<hr>
</body>
</html>
